import sys
import os
import phreeqpy.iphreeqc.phreeqc_dll as phreeqc_mod

import csv
import numpy as np

import copy


import molmass
import yaml

from phreeqcinwt.core.data_base_utils import dataBaseManagment
from phreeqcinwt.core.utility_functions import utilities
from phreeqcinwt.core.reaction_utils import reaction_utils
from phreeqcinwt.core.solution_state_utils import solution_utils


class phreeqcWTapi(dataBaseManagment, utilities, reaction_utils, solution_utils):
    def __init__(
        self,
        database=r"phreeqc.dat",
        db_dir=None,
        # database=r"minteq.v4.dat",
        rebuild_master_species=False,
        rebuild_soluton_species=False,
        rebuild_phases=False,
        log_phreeqc_commands=True,
        ignore_phase_list=None,
        track_phase_list=None,
        remove_phase_list=None,
        exclude_gases_in_phases=True,
    ):
        """this is main class for phreeqcAPI that will handle working with a single or multiple solutions
        this class is a higher level api for phreeqpy and abstraction method for phreeqc with
        focus on application in water treatment.

        the class creates and manages phreeqc provided databaes (please place the database from database install in
        /databases folder of the module)

        the class requires generation of meta data for each database, from which aviaalble master species, sub-spesies, and
        phases are extracted and used to aquire data from phreeqc. These can be auto generated by use the rebuild key words described below.

        The module includes pre-build databases metadata files for a view libraries and will be auto created if they don't exist.
        The only file user should manually modify is the database_SOLUTION_MASTER_SPECIES.yaml file, where user cans pecify
        thier explicity formula and mw for compound being used in thier reactions, althoug in most cases this is not required.

        If user species log_phreeqc_commands to true, they will be stored in command_log dictionary, under key "Action #" where
        the # is sequence of command send to phreeqc back end. These are usefull for debugging purposes, if results fail to be returened
        the user is encouraged to print out the log to consol and paste into phreeqc GUI and run it, as it will display the excat
        error for why phreeqc failed to return results. The log can be printed useing print_log method.

        Database directory should include metadata folder.

        Keyword arguments:
        db_dir -- diretory for data base files if None, uses local module dir (default None)
        database -- database to use by phreeqcy, (default r'minteq.v4.dat)
        rebuild_master_species -- rebuild meta data for master species list (default False)
        rebuild_soluton_species -- rebuild meta data for solution species list (default False)
        rebuild_phases -- rebuild meta data for phases list (default False)
        log_phreeqc_commands -- log phreeqc commands(default False)
        ignore_phase_list -- provide list of phases to not check for scaling and percipitaiton, can be updated useing exclude_phases method
        remove_phase_list -- list of phases to remove, this will remove it from provided database, the database will NOT be ovewritten
        """

        self.cwd = db_dir
        self.rebuild_metadata = [
            rebuild_master_species,
            rebuild_soluton_species,
            rebuild_phases,
        ]
        self.phreeqc = phreeqc_mod.IPhreeqc()
        self.database = database
        self.load_database(remove_phase_list)

        self.solution_name_reference = {}

        # number of current soluton and action being performed
        self.current_solution = 1
        self.current_action = 0
        # actions log
        self.command_log = {"log": log_phreeqc_commands}

        self.exclude_phases(
            ignore_phase_list, track_phase_list, exclude_gases_in_phases
        )

    def exclude_phases(
        self, ignore_list, track_phase_list=None, exclude_gases_in_phases=True
    ):
        """Method to exclude phases from being checked when getting scailing tendencies or percipitaiton
        to use, provide ignore_list, then call get_solution_state to update other relevant settings
        before calling any other functions

        Keyword arguments:
        ignore_list -- List of phases to ignore
        only_track_list -- oppsite of ingore_list, list that focuses only on the provided phase
        exclude_gases_in_phases -- exclude gases from ST and phases being removed.
        """
        self.db_metadata["CHECK_PHASE_LIST"] = self.db_metadata["PHASES"].keys()
        if ignore_list != None:
            new_phase_list = []
            ignored_list = []
            for k in self.db_metadata["CHECK_PHASE_LIST"]:
                if k not in ignore_list:
                    new_phase_list.append(k)
                else:
                    ignored_list.append(k)
            if len(ignore_list) != len(ignored_list):
                print(
                    "Failed to find all ignore phases!, only found {}".format(
                        ignored_list
                    )
                )
            self.db_metadata["CHECK_PHASE_LIST"] = new_phase_list
        if track_phase_list != None:
            new_phase_list = []
            added_list = []
            for k in self.db_metadata["CHECK_PHASE_LIST"]:
                if k in track_phase_list:
                    new_phase_list.append(k)
                    added_list.append(k)
            if len(track_phase_list) != len(added_list):
                print("Failed to find all phases!, only found {}".format(ignored_list))
            self.db_metadata["CHECK_PHASE_LIST"] = new_phase_list
        if exclude_gases_in_phases:
            gasless_list = []
            for phase in self.db_metadata["CHECK_PHASE_LIST"]:
                if "(g)" not in phase:
                    gasless_list.append(phase)
                else:
                    print("Ignoring gas phase {}".format(phase))
            self.db_metadata["CHECK_PHASE_LIST"] = gasless_list

    def build_water_composition(
        self,
        input_composotion,
        solution_number=None,
        solution_name=None,
        pH=7,
        temperature=25,
        pe=4,
        redox="pe",
        pressure=1,
        units="g/kgw",
        density=1,
        charge_balance="Cl",
        water_mass=1,
        assume_alkalinity=True,
        report=False,
    ):
        """
        This method is used to build a solution.  Input compositon should use either phreeqc species, formula, or solution speices as defined in
        SOLUTION_MASTER_SPECIES.yaml file. The input dict will be passed through build_ion_dict method, which will first check for component name in
        phreeqc species names, followed by formula, and finnaly by species, it will then return a dict that uses phreeqc specie names and formulas
        to be passed into phreeqc to build the solution (e.g if user provides SO4, it will be passed in as S(6) as SO4 into phreeqc).

        For Alkalinity, if you specify assume_alkalinity=True, and provide HCO3 or CaCO3 value in input_composition this will set Alkalinity and C(4)
        to same values, and pH for the solution will be calcualted by phreeqC
        If assume_alkalinity is set to False, passing in HCO3 will use C(4) only and pH will be fixed to explicity value specified by pH argument.
        If user wants to provide differnt Alkalinity and HCO3/CO3 concetraiton, set assume_alakalinity=False
        and explicity provide HCO3/CO3 for HCO3 concetration which will be set as C(4) and Alkalinity for solution.

        input_compositon should be a python dictionory with following possible structures
        {component_name: loading of componet (must be in same units as specified by units keywords)} - this will load in the ion and formula from SOLUTION_MASTER_SPECIES

        if you want to specify a custom compound for molality calcualtion during solution generation provide the following dict structure
        {compound_name: {'value': loading of compound as above, 'formula': chemical formula, use phreeqc notation, (optional)'mw': moleculare weight of formula }
        When fromula is provided and mw is not provided, molmass package will be used to update the mw in the loaded SOLUTION_MASTER_SPECIES database
        for reporting in g/kgw in solution composition, if molmass fails, please provide mw manually.

        The two structures can be mixed and matched, eg.
        {Na:1, HCO3:{'value':1,'formula':CaCO3, 'mw': 50.04}}
        For debuging solution composition please check the sent command by via print_log after building the solution

        Keyword arguments:
        input_composotion -- dictionary for input compositon
        solution_number -- solution number being generated (default None)
        solution_name -- name for the solution to save as (default None)
        pH -- solution pH (defualt 7)
        temperature -- solution temp in degrees C (default 25)
        pe -- solution pe - only needed for redox couples(default 4)
        redox -- redoux couple (default pe)
        pressure -- pressure of solution in atm (deafult 1)
        units -- units for input ions, can be any combionations of mass and volume units (defualt g/kgw)
        density -- density of solution, it will be calculated if database supports such calculations (default 1)
        charge_balance -- ion on which to perform the charge balance, needs to use phreeqc notation (default "Cl)
        water_mass -- mass of water in solution in kg (default 1)
        assume_alkalinity -- assume if HCO is provided its alkalinity, if TRUE include Alkalinity and C(4) with same concetraiton
        in solutin composition as HCO3 or CaCO3,
        note when CaCO3 phreeqc will use mw of 50.4 g/mol for it, and so will be mw in database (default True)
        report -- print report for solution state
        """
        self.input_composotion_raw = input_composotion
        self.input_composotion = self.build_ion_dict(
            input_composotion, assume_alkalinity=assume_alkalinity
        )
        self.water_mass = water_mass
        if solution_number is not None:
            self.current_solution = solution_number
        else:
            self.current_solution += 1
        self.store_solution_name(self.current_solution)

        self.composition = "SOLUTION {}\n".format(self.current_solution)
        self.composition += "   temp {}\n".format(temperature)
        self.composition += "   pressure {}\n".format(pressure)
        if charge_balance == "pH":
            self.composition += "   pH {} charge\n".format(pH)
        else:
            self.composition += "   pH {}\n".format(pH)
        self.composition += "   pe {}\n".format(pe)
        self.composition += "   units {}\n".format(units)
        self.composition += "   density {} calc\n".format(density)
        # self.composition += "   alk {} calc\n".format(density)

        for key, concentration in self.input_composotion.items():
            if key == charge_balance:
                charge = "charge"
            else:
                charge = ""
            # print("concentration", concentration)
            if isinstance(concentration, dict):
                if "compound" in concentration:
                    self.composition += "   {element}   {concentration} as {compound} {charge}\n".format(
                        element=key,
                        concentration=concentration["value"],
                        charge=charge,
                        compound=concentration["compound"],
                    )
                else:
                    self.composition += (
                        "   {element}   {concentration}    {charge}\n".format(
                            element=key,
                            concentration=concentration["value"],
                            charge=charge,
                        )
                    )

            else:
                self.composition += (
                    "   {element}   {concentration}    {charge}\n".format(
                        element=key, concentration=concentration, charge=charge
                    )
                )

        self.composition += "   -water  {} # kg\n".format(water_mass)
        self.composition += "SAVE SOLUTION {}\n".format(self.current_solution)
        self.composition += "END\n"

        self.run_string(self.composition)
        self.db_metadata[
            "MAJOR_SOLUTION_COMPONENTS"
        ] = self.phreeqc.get_component_list()
        result = self.get_solution_state(report=report)
        return result

    def perform_reaction(
        self,
        solution_number=None,
        solution_name=None,
        ph_adjust=None,
        reactants=None,
        temperature=None,
        pressure=None,
        evaporate_water_mass_percent=None,
        report=False,
    ):
        """
        Method for performing reaciton. ensure your reactant is present in defined_reactants.yaml in databases directory

        For reactants specifiy a dict with following structure
            to add specific amount of reactant use reactants key word {reactant:amount in mg/kgw}

        To adjust to specific pH use ph_adjust useing dict entery as {'reactant': reactant formula, 'pH':pH target}, if reactant is not specified will either use HCL or NaOH

        example for multiple reactants
        {{'HCl':100},{'NaOH':10}}
        only single pH adjust reactant can be used

        can enter ph_adjust and reacatant at same time but verify phreeqc can handle the calculation

        Keyword arguments:
        solution_number -- user provided solution nubmer to use (default None)
        solution_name -- name for the solution to save as (default None)
        reactants -- reactant use, should be a dict that includes reactant name and either mass or pH target,
        can contain multiple reactants {reactant:amount in mg} (default None)
        ph_adjust -- ph adjustant to use and target {'reactant': reactant formula, 'ph':pH target} (default None)
        pressure -- reaction pressure (default None)
        temperature -- reaction temperature (default None)
        evaporate_water_mass_percent -- percent of water to remove from solution, if negative, adds water to solution (default None)
        report -- print out titration results (default False)
        """
        if solution_number == None:
            solution_number = self.current_solution

        command = ""
        command += "USE SOLUTION {}\n".format(self.current_solution)
        # self.current_reaction += 1
        if temperature is not None:
            command += "REACTION_TEMPERATURE\n"
            command += "   {}\n".format(temperature)
        if pressure is not None:
            command += "REACTION_PRESSURE \n"
            command += "   {}\n".format(pressure)
        if reactants is not None or evaporate_water_mass_percent is not None:
            command += "REACTION\n"
            if reactants is not None:
                command = self._gen_reaction_command(command, reactants)
            if evaporate_water_mass_percent is not None:
                command = self._gen_evap_command(command, evaporate_water_mass_percent)
        if ph_adjust is not None:
            command = self._gen_titration_command(command, ph_adjust)

        command += "SELECTED_OUTPUT\n"
        command += " -equilibrium_phases Fix_H+ Fix_OH-\n"
        self.current_solution += 1
        command += "SAVE SOLUTION {}\n".format(self.current_solution)
        command += "END\n"
        self.store_solution_name(solution_name)
        self.run_string(command)
        reaction_dict = {}

        # if ph_adjust is not None:
        result = self.phreeqc.get_selected_output_array()

        if ph_adjust is not None:
            idx = np.where("d_Fix_H+" == np.array(result[0]))[0][0]
            reaction_dict = self.set_titrant_dict(
                reaction_dict, "acid", result[1][idx] * -1
            )
            idx = np.where("d_Fix_OH-" == np.array(result[0]))[0][0]
            reaction_dict = self.set_titrant_dict(
                reaction_dict, "base", result[1][idx] * -1
            )
        idx = np.where("pH" == np.array(result[0]))[0][0]
        reaction_dict["pH"] = {"value": result[1][idx]}

        if report:
            print("titration results---------")
            for key, result in reaction_dict.items():
                print("\t", key, result)
        return reaction_dict

    def get_solution_state(
        self,
        solution_number=None,
        report=False,
        units=True,
        return_above=1e-16,
        return_input_names=True,
    ):
        """Method for getting solution state.
        This will get the state of current active solution or
        provided solution number and return solution information including
        alkalinity, temperature, ph, ionic strength, charge balance, error in charge balance
        molalaitys of species and sub-species, and pre-scailing tendecies


        Keyword arguments:
        solution_number -- user provided solution nubmer to use (default None)
        report -- to print aquired data into consol (default False)
        units -- to convert molalities for major species from mol/kgw to g/kgw. If MW is not avaialble will reutrn mol/kg
        refer to units in returned dict (default True)
        return_above -- only returns molalaties that are above provided value (default 1e-16)
        return_input_names -- uses formulas provided by input dict when generating solution, if false, will return
        specie names as defined by phreeqc used database (deafult True)

        returns:
        dict -- keys:
                    'composition':dict - containst composition and sub-species
                    'solution_state': dict - general solution information, such as pH, etc
                    'scaling_tendencies': dict - scalining tendencies for tracked phases
        """
        if solution_number == None:
            solution_number = self.current_solution
        command = "USE SOLUTION {}\n".format(str(solution_number))

        command += "EQUILIBRIUM_PHASES\n"
        command += "USER_PUNCH\n"
        command += "-heading density h2o_vm\n"
        command += "-start\n"
        command += "10 punch RHO\n"
        command += "20 PUNCH VM('H2O')\n"
        command += "-end\n"
        # command = self._get_species_volumes(command)
        command += "SELECTED_OUTPUT\n"
        command += " -alkalinity true\n"
        command += " -temperature true\n"
        command += " -ionic_strength true\n"
        command += " -charge_balance true\n"
        command += " -water true\n"

        command += " -percent_error true\n"
        command += " -user_punch true\n"
        command += " -saturation_indices "

        for key in self.db_metadata["CHECK_PHASE_LIST"]:
            command += key + " "
        command += "\n"
        command += " -activities "
        for element, name in self.return_dict.items():
            command += " {} ".format(element)
        command += " H2O "
        command += "\n"
        command += " -totals"
        for element, name in self.forward_dict.items():
            command += " {} ".format(name)
        command += "\n"
        command += " -molalities"
        for element, name in self.return_dict.items():
            for spc in self.db_metadata["SOLUTION_SPECIES"][element]["sub_species"]:
                command += " {} ".format(spc)

        command += "\n"
        command += "END\n"

        self.run_string(command)

        result = self.phreeqc.get_selected_output_array()

        solution_composition = {}
        solution_composition = self._get_scaling_tendencies(
            result,
        )
        solution_composition["activities"] = self._process_activities(result)

        solution_composition["composition"] = self._get_solution_comp(
            result,
            return_input_names=return_input_names,
            units=units,
            return_above=return_above,
        )
        solution_composition["solution_state"].update(
            self.get_total_concetration(solution_composition)
        )
        solution_composition["solution_state"][
            "Osmotic pressure"
        ] = self._get_osmotic_pressure(
            result,
            solution_composition["solution_state"],
            solution_composition["activities"],
        )
        if report:
            print("solution state--------------")
            for key, result in solution_composition["solution_state"].items():
                print("\t", key, result["value"], result["units"])
            print("ion composion------------------")
            for ion, mass in solution_composition["composition"].items():
                print(
                    ion,
                    mass["value"],
                    mass["units"],
                    "original input",
                    self.input_composotion[self.forward_dict[ion]]["value"],
                )
                for sub, values in mass["sub_species"].items():
                    print("\t", sub, values["value"], values["units"])
            print("scaling tendendencies------------------")
            for scalant, SI in solution_composition["scaling_tendencies"].items():
                if scalant == "max":
                    print("\t", scalant, SI["value"], SI["scalant"])
                else:
                    print("\t", scalant, SI["value"])

        return copy.deepcopy(solution_composition)

    def form_phases(
        self,
        solution_number=None,
        solution_name=None,
        phases=None,
        store_solution=True,
        return_non_zero=False,
        force_all_phases_in_db=False,
        report=False,
    ):
        """Method for getting solution state.
        This method will percipitate all formed phases from solution (changing composition)
        if you want to perform the percipitaiton but not affect solution, set store_solution=False
        to only percipitate specific phase provide phase name using same nomeclature as in PHASES metedata yaml
        in /databases/metadata

        Keyword arguments:
        solution_number -- user provided solution nubmer to use (default None)
        solution_name -- name for the solution to save as (default None)
        phaes -- specifiy phases to percipiate out, if none, will get all available phases (default None)
        store_solution -- save solution after percipiation with new sol number (default True)
        return_non_zero -- only return phases that percipaited (default False)
        force_all_phases_in_db -- if  true, will get all phases avaiable in database and
        not just those reported as available by phreeqc (default False)
        report -- print out results (default False)
        """
        if solution_number == None:
            solution_number = self.current_solution
        if phases is None:
            phases = list(self.db_metadata["PRESENT_PHASES_IN_SOLUTION"])
            if force_all_phases_in_db:
                phases = list(self.db_metadata["PHASES"].keys())
        command = "USE SOLUTION {}\n".format(self.current_solution)
        command += "EQUILIBRIUM_PHASES\n"
        for phase in phases:
            command += "    {}  0   0\n".format(phase)
        command += "SELECTED_OUTPUT\n"
        command += "-equilibrium_phases"
        for phase in phases:
            command += " {}".format(phase)
        command += "\n"
        if store_solution:
            self.current_solution += 1
            command += "SAVE SOLUTION {}\n".format(self.current_solution)
            self.store_solution_name(solution_name)
        command += "END\n"
        self.run_string(command)
        result = self.phreeqc.get_selected_output_array()
        percip_result = {}
        # print(result)
        for k in phases:
            idx = np.where(k == np.array(result[0]))[0][0]
            idx_d = np.where("d_" + k == np.array(result[0]))[0][0]
            mols = result[1][idx_d]
            if return_non_zero:
                if mols > 0:
                    percip_result[k] = {
                        "value": result[1][idx_d] / self.water_mass,
                        "units": "mol/kgw",
                    }
            elif mols > -999:
                percip_result[k] = {
                    "value": result[1][idx_d] / self.water_mass,
                    "units": "mol/kgw",
                }
        if report:
            print("precip results--------------------")
            for phase, amount in percip_result.items():
                print("\t", phase, amount)
        return percip_result

    def get_vapor_pressure(self, report=False):
        """Method for getting vapor pressure
        This will return fugacities for the for each gas phase. the fugacity is
        equivlaent to vapor pressure at low pressures. The sum of all fugacities is
        total vapor pressure.

        Keyword arguments:
        report -- print out results (default False)
        """
        gas_phases = []
        gas_header = []

        for phase in list(self.db_metadata["PHASES"].keys()):
            if "(g)" in phase:
                gas_phases.append(phase)
                gas_header.append("fugacity_{}".format(phase))
        # print(gas_phases)
        command = "USE SOLUTION {}\n".format(self.current_solution)
        command += "GAS_PHASE 1\n"
        command += "   -fixed_volume\n"
        for g in gas_phases:
            command += "    {}\n".format(g)
        command += "   -fixed_volume\n"
        # command += "END\n"
        # command += "USE REACTION\n"  # .format(self.current_solution)
        # command += "USE gas_phase 1\n"
        #        command += "REACTION_TEMPERATURE\n"
        #       command += "   {}\n".format(temperture)
        # command += "END\n"
        command += "USER_PUNCH\n"
        command += "-start\n"
        command += "-headings {}\n".format(" ".join(gas_header))
        for i, g in enumerate(gas_phases):
            command += '{} PUNCH SR("{}")\n'.format(int(i * 10), g)
        command += "-end\n"
        command += "SELECTED_OUTPUT\n"
        command += "   -gases {}".format(" ".join(gas_phases))
        command += "   -user_punch True"
        command += "END\n"
        self.run_string(command)
        result = self.phreeqc.get_selected_output_array()
        out_dict = {}
        # print(result)
        total = 0
        for k in gas_phases:
            # print("fugacity_{}".format(k))
            idx = np.where("fugacity_{}".format(k) == np.array(result[0]))[0][0]
            out_dict[k] = {"value": result[1][idx], "units": "atm"}
            total += result[1][idx]
        out_dict["total_fugacity"] = {"value": total, "units": "atm"}
        if report:
            print("vapor pressures-----------")
            for comp, vapor in out_dict.items():
                print("\t", comp, vapor["value"], vapor["units"])
        # print("vapor", out_dict)  # , result[1][idx])
        return out_dict

    def mix_solutions(
        self,
        solutin_dict,
        new_solution_number=None,
        solution_name=None,
    ):
        """Method for mixing solutions, will be saved as new solution, by advancing
        current_solution number by 1

        Keyword arguments:
        solutin_dict -- dictionary of solution names and ratios to mix
        solution_name -- name for the solution to save as (default None)
        new_solution_number -- provide numbber for solution to use as (defaoult None)
        report -- print out results (default False)
        """
        command = "MIX\n"  # .format(self.current_solution)
        for solution, fraction in solutin_dict.items():
            command += " {} {}\n".format(solution, fraction)
        # if save_solution:
        if new_solution_number is not None:
            self.current_solution = new_solution_number
        else:
            self.current_solution += 1
        self.store_solution_name(solution_name)
        command += "SAVE SOLUTION {}\n".format(self.current_solution)
        command += "END\n"
        # print(command)
        self.run_string(command)

    def get_enthalpy_phase(self, report=True):
        """Method for heat of reaction for phases
        this uses non-documented fucntion and described as follows
        "I wrote two functions DELTA_H_SPECIES(species name)
        and DELTA_H_PHASE(phase name). They numerically evaluate the delta H.
        if an analytical expression exists, the result will be at the
        temperature of the calculation.
        If no analytical expression exists,
        the numerical result should be equal to the delta H
         specified in SOLUTION_SPECIES or PHASES."
         Source "https://phreeqcusers.org/index.php?topic=447.0"


        Keyword arguments:
        report -- print out results (default False)
        """
        h_phases = []
        h_header = []
        for phase in self.db_metadata["PRESENT_PHASES_IN_SOLUTION"]:
            h_header.append("delta_h_{}".format(phase))
        # print(gas_phases)
        command = "USE SOLUTION {}\n".format(self.current_solution)
        command += "EQUILIBRIUM_PHASES\n"
        command += "USER_PUNCH\n"
        command += "-start\n"
        command += "-headings {}\n".format(" ".join(h_header))
        for i, g in enumerate(self.db_metadata["PRESENT_PHASES_IN_SOLUTION"]):
            command += '{} PUNCH DELTA_H_PHASE("{}")\n'.format(int(i * 10), g)
        command += "-end\n"
        command += "SELECTED_OUTPUT\n"
        command += "   -user_punch True\n"
        command += "END\n"
        # print(command)
        self.run_string(command)
        result = self.phreeqc.get_selected_output_array()
        out_dict = {}
        # print(result)
        total = 0
        for k in self.db_metadata["PRESENT_PHASES_IN_SOLUTION"]:
            # print("fugacity_{}".format(k))
            idx = np.where("delta_h_{}".format(k) == np.array(result[0]))[0][0]
            out_dict[k] = {"value": result[1][idx], "units": "kJ/mol"}
            # total += result[1][idx]
        # out_dict["heat_of_reaction"] = total
        if report:
            print("heat of reaction-----------")
            for comp, vapor in out_dict.items():
                print("\t", comp, vapor["value"])
        # print("vapor", out_dict)  # , result[1][idx])
        return out_dict

    def get_enthalpy_species(self, report=True):
        """Method for heat of reaction for species
        this uses non-documented fucntion and described as follows
        "I wrote two functions DELTA_H_SPECIES(species name)
        and DELTA_H_PHASE(phase name). They numerically evaluate the delta H.
        if an analytical expression exists, the result will be at the
        temperature of the calculation.
        If no analytical expression exists,
        the numerical result should be equal to the delta H
         specified in SOLUTION_SPECIES or PHASES."
         Source "https://phreeqcusers.org/index.php?topic=447.0"


        Keyword arguments:
        report -- print out results (default False)
        """
        h_phases = []
        h_header = []

        for element, name in self.return_dict.items():
            for spc in self.db_metadata["SOLUTION_SPECIES"][element]["sub_species"]:
                h_header.append("delta_h_{}".format(spc))
                h_phases.append(spc)
        # print(gas_phases)
        command = "USE SOLUTION {}\n".format(self.current_solution)
        command += "EQUILIBRIUM_PHASES\n"
        command += "USER_PUNCH\n"
        command += "-start\n"
        command += "-headings {}\n".format(" ".join(h_header))
        for i, g in enumerate(h_phases):
            command += '{} PUNCH DELTA_H_SPECIES("{}")\n'.format(int(i * 10), g)
        command += "-end\n"
        command += "SELECTED_OUTPUT\n"
        command += "   -user_punch True\n"
        command += "END\n"
        # print(command)
        self.run_string(command)
        result = self.phreeqc.get_selected_output_array()
        out_dict = {}
        # print(result)
        total = 0
        for element, name in self.return_dict.items():
            for k in self.db_metadata["SOLUTION_SPECIES"][element]["sub_species"]:
                # print("fugacity_{}".format(k))
                idx = np.where("delta_h_{}".format(k) == np.array(result[0]))[0][0]
                out_dict[k] = {"value": result[1][idx], "units": "kJ/mol"}
            # total += result[1][idx]
        # out_dict["heat_of_reaction"] = total
        if report:
            print("heat of reaction-----------")
            for comp, vapor in out_dict.items():
                print("\t", comp, vapor["value"])
        # print("vapor", out_dict)  # , result[1][idx])
        return out_dict
